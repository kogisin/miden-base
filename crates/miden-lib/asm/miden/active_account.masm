use.miden::kernel_proc_offsets

# ACTIVE ACCOUNT PROCEDURES
# =================================================================================================

# ID AND NONCE
# -------------------------------------------------------------------------------------------------

#! Returns the ID of the active account.
#!
#! Inputs:  []
#! Outputs: [account_id_prefix, account_id_suffix]
#!
#! Where:
#! - account_id_{prefix,suffix} are the prefix and suffix felts of the ID of the active account.
#!
#! Invocation: exec
export.get_id
    # pad the stack
    padw padw padw push.0.0
    # => [pad(14)]

    # push the flag indicating that the ID of the current account was requested
    push.0
    # => [is_native = 0, pad(14)]

    exec.kernel_proc_offsets::account_get_id_offset
    # => [offset, is_native = 0, pad(14)]

    syscall.exec_kernel_proc
    # => [account_id_prefix, account_id_suffix, pad(14)]

    # clean the stack
    swapdw dropw dropw swapw dropw movdn.3 movdn.3 drop drop
    # => [account_id_prefix, account_id_suffix]
end

#! Returns the nonce of the active account.
#!
#! This procedure always returns the initial account nonce, as the nonce can only be incremented
#! in the authentication procedure when signing the transaction after all user code has been
#! executed.
#!
#! Inputs:  []
#! Outputs: [nonce]
#!
#! Where:
#! - nonce is the active account's nonce.
#!
#! Invocation: exec
export.get_nonce
    # pad the stack
    padw padw padw push.0.0.0
    # => [pad(15)]

    exec.kernel_proc_offsets::account_get_nonce_offset
    # => [offset, pad(15)]

    syscall.exec_kernel_proc
    # => [nonce, pad(15)]

    # clean the stack
    swapdw dropw dropw swapw dropw movdn.3 drop drop drop
    # => [nonce]
end

# COMMITMENTS
# -------------------------------------------------------------------------------------------------

#! Returns the commitment of the active account at the beginning of the transaction.
#!
#! Inputs:  []
#! Outputs: [INIT_COMMITMENT]
#!
#! Where:
#! - INIT_COMMITMENT is the initial account commitment.
#!
#! Invocation: exec
export.get_initial_commitment
    # pad the stack
    padw padw padw push.0.0.0
    # => [pad(15)]

    exec.kernel_proc_offsets::account_get_initial_commitment_offset
    # => [offset, pad(15)]

    syscall.exec_kernel_proc
    # => [INIT_COMMITMENT, pad(12)]

    # clean the stack
    swapdw dropw dropw swapw dropw
    # => [INIT_COMMITMENT]
end

#! Computes and returns commitment to the state of the active account.
#!
#! Inputs:  []
#! Outputs: [ACCOUNT_COMMITMENT]
#!
#! Where:
#! - ACCOUNT_COMMITMENT is the commitment of the account data.
#!
#! Invocation: exec
export.compute_commitment
    # pad the stack
    padw padw padw push.0.0.0
    # => [pad(15)]

    exec.kernel_proc_offsets::account_compute_commitment_offset
    # => [offset, pad(15)]

    syscall.exec_kernel_proc
    # => [ACCOUNT_COMMITMENT, pad(12)]

    # clean the stack
    swapdw dropw dropw swapw dropw
    # => [ACCOUNT_COMMITMENT]
end

#! Gets the code commitment of the active account.
#!
#! Notice that the account code cannot be changed during the user code execution, so the code
#! commitment doesn't change during transaction execution: commitment returned by this procedure
#! could be used as both the initial and the current.
#!
#! The commitment to an empty delta is defined as the empty word.
#!
#! During an account-creating transaction (when the initial nonce is 0), this procedure will not
#! return the empty word even if the initial storage commitment and the current storage commitment
#! are identical (storage hasn't changed). This is because the delta for a new account must
#! represent its entire newly created state, and the initial storage in a transaction is
#! initialized to the the storage that the account ID commits to, which may be non-empty. This
#! does not have any consequences other than being inconsistent in this edge case.
#!
#! Inputs:  []
#! Outputs: [CODE_COMMITMENT]
#!
#! Where:
#! - CODE_COMMITMENT is the commitment of the account code.
#!
#! Invocation: exec
export.get_code_commitment
    # pad the stack
    padw padw padw push.0.0.0
    # => [pad(15)]

    exec.kernel_proc_offsets::account_get_code_commitment_offset
    # => [offset, pad(15)]

    syscall.exec_kernel_proc
    # => [CODE_COMMITMENT, pad(12)]

    # clean the stack
    swapdw dropw dropw swapw dropw
    # => [CODE_COMMITMENT]
end

#! Returns the storage commitment of the active account at the beginning of the transaction.
#!
#! During an account-creating transaction (when the initial nonce is 0), this procedure and
#! compute_storage_commitment will return the same value at the beginning of the transaction
#! (before any note or transaction scripts were executed). Despite that, the account delta may
#! not be empty. See account::compute_delta_commitment for more.
#!
#! Inputs:  []
#! Outputs: [INIT_STORAGE_COMMITMENT]
#!
#! Where:
#! - INIT_STORAGE_COMMITMENT is the initial account storage commitment.
#!
#! Invocation: exec
export.get_initial_storage_commitment
    # pad the stack
    padw padw padw push.0.0.0
    # => [pad(15)]

    exec.kernel_proc_offsets::account_get_initial_storage_commitment_offset
    # => [offset, pad(15)]

    syscall.exec_kernel_proc
    # => [INIT_STORAGE_COMMITMENT, pad(12)]

    # clean the stack
    swapdw dropw dropw swapw dropw
    # => [INIT_STORAGE_COMMITMENT]
end

#! Computes the latest storage commitment of the active account.
#!
#! Notice that this procedure always returns the latest commitment, but it doesn't actually always
#! recompute it: recomputation is performed only if the account's storage has been changed,
#! otherwise the cached value is returned.
#!
#! During an account-creating transaction (when the initial nonce is 0), this procedure and
#! get_initial_storage_commitment will return the same value at the beginning of the transaction
#! (before any note or transaction scripts were executed). Despite that, the account delta may
#! not be empty. See account::compute_delta_commitment for more.
#!
#! Inputs:  []
#! Outputs: [STORAGE_COMMITMENT]
#!
#! Where:
#! - STORAGE_COMMITMENT is the commitment of the account storage.
#!
#! Invocation: exec
export.compute_storage_commitment
    # pad the stack
    padw padw padw push.0.0.0
    # => [pad(15)]

    exec.kernel_proc_offsets::account_compute_storage_commitment_offset
    # => [offset, pad(15)]

    syscall.exec_kernel_proc
    # => [STORAGE_COMMITMENT, pad(12)]

    # clean the stack
    swapdw dropw dropw swapw dropw
    # => [STORAGE_COMMITMENT]
end

#! Returns the vault root of the active account at the beginning of the transaction.
#!
#! Inputs:  []
#! Outputs: [INIT_VAULT_ROOT]
#!
#! Where:
#! - INIT_VAULT_ROOT is the initial account vault root.
#!
#! Invocation: exec
export.get_initial_vault_root
    # pad the stack
    padw padw padw push.0.0.0
    # => [pad(15)]

    exec.kernel_proc_offsets::account_get_initial_vault_root_offset
    # => [offset, pad(15)]

    syscall.exec_kernel_proc
    # => [INIT_VAULT_ROOT, pad(12)]

    # clean the stack
    swapdw dropw dropw swapw dropw
    # => [INIT_VAULT_ROOT]
end

#! Returns the vault root of the active account.
#!
#! Inputs:  []
#! Outputs: [VAULT_ROOT]
#!
#! Where:
#! - VAULT_ROOT is the root of the account vault.
#!
#! Invocation: exec
export.get_vault_root
    # pad the stack for syscall invocation
    padw padw padw push.0.0.0
    # => [pad(15)]

    exec.kernel_proc_offsets::account_get_vault_root_offset
    # => [offset, pad(15)]

    syscall.exec_kernel_proc
    # => [VAULT_ROOT, pad(12)]

    # clean the stack
    swapdw dropw dropw swapw dropw
    # => [VAULT_ROOT]
end

# STORAGE
# -------------------------------------------------------------------------------------------------

#! Gets an item from the active account storage. Panics if the index is out of bounds.
#!
#! Inputs:  [index]
#! Outputs: [VALUE]
#!
#! Where:
#! - index is the index of the item to get.
#! - VALUE is the value of the item.
#!
#! Panics if:
#! - the index of the requested item is out of bounds.
#!
#! Invocation: exec
export.get_item
    push.0.0 movup.2
    # => [index, 0, 0]

    exec.kernel_proc_offsets::account_get_item_offset
    # => [offset, index, 0, 0]

    # pad the stack
    padw swapw padw padw swapdw
    # => [offset, index, pad(14)]

    syscall.exec_kernel_proc
    # => [VALUE, pad(12)]

    # clean the stack
    swapdw dropw dropw swapw dropw
    # => [VALUE]
end

#! Gets the initial item from the active account storage slot as it was at the beginning of the
#! transaction.
#!
#! Inputs:  [index]
#! Outputs: [INIT_VALUE]
#!
#! Where:
#! - index is the index of the item to get.
#! - INIT_VALUE is the initial value of the item at the beginning of the transaction.
#!
#! Panics if:
#! - the index of the requested item is out of bounds.
#!
#! Invocation: exec
export.get_initial_item
    push.0.0 movup.2
    # => [index, 0, 0]

    exec.kernel_proc_offsets::account_get_initial_item_offset
    # => [offset, index, 0, 0]

    # pad the stack
    padw swapw padw padw swapdw
    # => [offset, index, pad(14)]

    syscall.exec_kernel_proc
    # => [INIT_VALUE, pad(12)]

    # clean the stack
    swapdw dropw dropw swapw dropw
    # => [INIT_VALUE]
end

#! Gets a map item from the active account storage.
#!
#! Inputs:  [index, KEY]
#! Outputs: [VALUE]
#!
#! Where:
#! - index is the index of the map where the KEY VALUE should be read.
#! - KEY is the key of the item to get.
#! - VALUE is the value of the item.
#!
#! Panics if:
#! - the index for the map is out of bounds, meaning > 255.
#! - the slot item at index is not a map.
#!
#! Invocation: exec
export.get_map_item
    exec.kernel_proc_offsets::account_get_map_item_offset
    # => [offset, index, KEY]

    # pad the stack
    push.0.0 movdn.7 movdn.7 padw padw swapdw
    # => [offset, index, KEY, pad(10)]

    syscall.exec_kernel_proc
    # => [VALUE, pad(12)]

    # clean the stack
    swapdw dropw dropw swapw dropw
    # => [VALUE]
end

#! Gets the initial VALUE from the active account storage map as it was at the beginning of the
#! transaction.
#!
#! Inputs:  [index, KEY]
#! Outputs: [INIT_VALUE]
#!
#! Where:
#! - index is the index of the map where the KEY VALUE should be read.
#! - KEY is the key of the item to get.
#! - INIT_VALUE is the initial value of the item at the beginning of the transaction.
#!
#! Panics if:
#! - the index for the map is out of bounds, meaning > 255.
#! - the slot item at index is not a map.
#!
#! Invocation: exec
export.get_initial_map_item
    exec.kernel_proc_offsets::account_get_initial_map_item_offset
    # => [offset, index, KEY]

    # pad the stack
    push.0.0 movdn.7 movdn.7 padw padw swapdw
    # => [offset, index, KEY, pad(10)]

    syscall.exec_kernel_proc
    # => [INIT_VALUE, pad(12)]

    # clean the stack
    swapdw dropw dropw swapw dropw
    # => [INIT_VALUE]
end

# VAULT
# -------------------------------------------------------------------------------------------------

#! Returns the balance of the fungible asset associated with the provided faucet_id in the active
#! account's vault.
#!
#! Inputs:  [faucet_id_prefix, faucet_id_suffix]
#! Outputs: [balance]
#!
#! Where:
#! - faucet_id_{prefix,suffix} are the prefix and suffix felts of the faucet ID of the fungible
#!   asset of interest.
#! - balance is the vault balance of the fungible asset.
#!
#! Panics if:
#! - the provided faucet ID is not an ID of a fungible faucet.
#!
#! Invocation: exec
export.get_balance
    exec.kernel_proc_offsets::account_get_balance_offset
    # => [offset, faucet_id_prefix, faucet_id_suffix]

    # pad the stack
    push.0 movdn.3 padw swapw padw padw swapdw
    # => [offset, faucet_id_prefix, faucet_id_suffix, pad(13)]

    syscall.exec_kernel_proc
    # => [balance, pad(15)]

    # clean the stack
    swapdw dropw dropw swapw dropw movdn.3 drop drop drop
    # => [balance]
end

#! Returns the balance of the fungible asset associated with the provided faucet_id in the active 
#! account's vault at the beginning of the transaction.
#!
#! Inputs:  [faucet_id_prefix, faucet_id_suffix]
#! Outputs: [init_balance]
#!
#! Where:
#! - faucet_id_{prefix, suffix} are the prefix and suffix felts of the faucet id of the fungible
#!   asset of interest.
#! - init_balance is the vault balance of the fungible asset at the beginning of the transaction.
#!
#! Panics if:
#! - the provided faucet ID is not an ID of a fungible faucet.
#!
#! Invocation: exec
export.get_initial_balance
    exec.kernel_proc_offsets::account_get_initial_balance_offset
    # => [offset, faucet_id_prefix, faucet_id_suffix]

    # pad the stack
    push.0 movdn.3 padw swapw padw padw swapdw
    # => [offset, faucet_id_prefix, faucet_id_suffix, pad(13)]

    syscall.exec_kernel_proc
    # => [init_balance, pad(15)]

    # clean the stack
    swapdw dropw dropw swapw dropw movdn.3 drop drop drop
    # => [init_balance]
end

#! Returns a boolean indicating whether the non-fungible asset is present in the active account's
#! vault.
#!
#! Inputs:  [ASSET]
#! Outputs: [has_asset]
#!
#! Where:
#! - ASSET is the non-fungible asset of interest
#! - has_asset is a boolean indicating whether the account vault has the asset of interest
#!
#! Panics if:
#! - the ASSET is a fungible asset.
#!
#! Invocation: exec
export.has_non_fungible_asset
    exec.kernel_proc_offsets::account_has_non_fungible_asset_offset
    # => [offset, ASSET]

    # pad the stack
    push.0.0.0 movdn.7 movdn.7 movdn.7 padw padw swapdw
    # => [offset, ASSET, pad(11)]

    syscall.exec_kernel_proc
    # => [has_asset, pad(15)]

    # clean the stack
    swapdw dropw dropw swapw dropw movdn.3 drop drop drop
    # => [has_asset]
end

#! Returns the number of procedures in the active account.
#!
#! Inputs:  []
#! Outputs: [num_procedures]
#!
#! Where:
#! - num_procedures is the number of procedures in the active account.
#!
#! Invocation: exec
export.get_num_procedures
    # pad the stack
    padw padw padw push.0.0.0
    # => [pad(15)]

    exec.kernel_proc_offsets::account_get_num_procedures_offset
    # => [offset, pad(15)]

    syscall.exec_kernel_proc
    # => [num_procedures, pad(15)]

    # clean the stack
    swap.15 dropw dropw dropw drop drop drop
    # => [num_procedures]
end

#! Returns the procedure root for the procedure at the specified index in the active account.
#!
#! Inputs:  [index]
#! Outputs: [PROC_ROOT]
#!
#! Where:
#! - index is the index of the procedure.
#! - PROC_ROOT is the hash of the procedure.
#!
#! Panics if:
#! - the procedure index is out of bounds.
#!
#! Invocation: exec
export.get_procedure_root
    # => [index]

    push.0.0 movup.2
    exec.kernel_proc_offsets::account_get_procedure_root_offset
    # => [offset, index, 0, 0]

    # pad the stack
    padw swapw padw padw swapdw
    # => [offset, index, pad(14)]

    syscall.exec_kernel_proc
    # => [PROC_ROOT, pad(12)]

    # clean the stack
    swapdw dropw dropw swapw dropw
    # => [PROC_ROOT]
end

#! Returns the binary flag indicating whether the procedure with the provided root is available on
#! the active account.
#!
#! Returns 1 if the procedure is available on the active account and 0 otherwise.
#!
#! Inputs:  [PROC_ROOT]
#! Outputs: [is_procedure_available]
#!
#! Where:
#! - PROC_ROOT is the hash of the procedure of interest.
#! - is_procedure_available is the binary flag indicating whether the procedure with PROC_ROOT is 
#!   available on the active account.
#!
#! Invocation: exec
export.has_procedure
    exec.kernel_proc_offsets::account_has_procedure_offset
    # => [offset, PROC_ROOT]

    # pad the stack
    push.0.0.0 movdn.7 movdn.7 movdn.7 padw padw swapdw
    # => [offset, PROC_ROOT, pad(11)]

    syscall.exec_kernel_proc
    # => [is_procedure_available, pad(15)]

    # clean the stack
    swapdw dropw dropw swapw dropw movdn.3 drop drop drop
    # => [is_procedure_available]
end
